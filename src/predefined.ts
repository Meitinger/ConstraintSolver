/*
 * Constraint Solver for FUN Programs
 * Copyright (C) 2022  Manuel Meitinger
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

export const predefinedRules = {
  'Control Flow Analysis': [
    'const condition = (label: number, callable: Expression, result: Expression): Rule["lhs"] => {',
    '    return ({',
    '        dynamic: ([functionLabels, values]) => functionLabels.has(label) ? values : [],',
    '        dependencies: [{ expression: callable }, { expression: result }]',
    '    })',
    '}',
    'for (const var_ of type("var")) {',
    '    define({',
    '        lhs: { variable: var_ },',
    '        rhs: { expression: var_ }',
    '    })',
    '}',
    'for (const fn of type("fn")) {',
    '    define({',
    '        lhs: { constant: fn.label },',
    '        rhs: { expression: fn }',
    '    })',
    '}',
    'for (const fun of type("fun")) {',
    '    define({',
    '        lhs: { constant: fun.label },',
    '        rhs: { expression: fun }',
    '    })',
    '    define({',
    '        lhs: { constant: fun.label },',
    '        rhs: { functionVariable: fun }',
    '    })',
    '}',
    'for (const app of type("app")) {',
    '    for (const fn of type("fn", "fun")) {',
    '        define({',
    '            lhs: condition(fn.label, app.callable, app.argument),',
    '            rhs: { boundVariable: fn }',
    '        })',
    '        define({',
    '            lhs: condition(fn.label, app.callable, fn.body),',
    '            rhs: { expression: app }',
    '        })',
    '    }',
    '}',
    'for (const if_ of type("if")) {',
    '    define({',
    '        lhs: { expression: if_.thenBody },',
    '        rhs: { expression: if_ }',
    '    })',
    '    define({',
    '        lhs: { expression: if_.elseBody },',
    '        rhs: { expression: if_ }',
    '    })',
    '}',
    'for (const let_ of type("let")) {',
    '    define({',
    '        lhs: { expression: let_.value },',
    '        rhs: { boundVariable: let_ }',
    '    })',
    '    define({',
    '        lhs: { expression: let_.body },',
    '        rhs: { expression: let_ }',
    '    })',
    '}',
    ''
  ].join('\r\n'),
  'Detection of Sign Analysis': [
    'type Operation = Expression & { type: Operators }',
    '',
    'const handleOperation = <T>(',
    '    expression: Operation,',
    '    sample: (types: ReadonlySet<string | number>) => T[],',
    '    test: (a: T, b: T) => string',
    '): void => {',
    '    handle(expression.left)',
    '    handle(expression.right)',
    '    define({',
    '        lhs: {',
    '            dynamic: ([left, right]) => {',
    '                const types = new Set<string>()',
    '                const leftValues = sample(left)',
    '                const rightValues = sample(right)',
    '                for (const leftValue of leftValues) {',
    '                    for (const rightValue of rightValues) {',
    '                        types.add(test(leftValue, rightValue))',
    '                    }',
    '                }',
    '                return types',
    '            },',
    '            dependencies: [{ expression: expression.left }, { expression: expression.right }]',
    '        },',
    '        rhs: { expression }',
    '    })',
    '}',
    '',
    'const handleBoolean = (',
    '    expression: Operation,',
    '    test: (a: boolean, b: boolean) => boolean',
    '): void => handleOperation<boolean>(expression, types => {',
    '    const values = new Array<boolean>()',
    '    if (types.has("tt")) { values.push(true) }',
    '    if (types.has("ff")) { values.push(false) }',
    '    return values',
    '}, (a, b) => test(a, b) ? "tt" : "ff")',
    '',
    'const handleNumeric = (',
    '    expression: Operation,',
    '    test: (a: number, b: number) => string',
    '): void => handleOperation<number>(expression, types => {',
    '    const values = new Array<number>()',
    '    if (types.has("-")) {',
    '        values.push(-1)',
    '        values.push(-2)',
    '    }',
    '    if (types.has("0")) {',
    '        values.push(0)',
    '    }',
    '    if (types.has("+")) {',
    '        values.push(1)',
    '        values.push(2)',
    '    }',
    '    return values',
    '}, test);',
    '',
    'const handleArithmetic = (',
    '    expression: Operation,',
    '    test: (a: number, b: number) => number',
    '): void => handleNumeric(expression, (a, b) => {',
    '    const result = test(a, b)',
    '    return result > 0 ? "+" : result < 0 ? "-" : "0"',
    '})',
    '',
    'const handleComparison = (',
    '    expression: Operation,',
    '    test: (a: number, b: number) => boolean',
    '): void => handleNumeric(expression, (a, b) => test(a, b) ? "tt" : "ff")',
    '',
    'const handle = (expression: Expression): void => {',
    '    switch (expression.type) {',
    '        case "n":',
    '            define({',
    '                lhs: { constant: expression.value > 0 ? "+" : expression.value < 0 ? "-" : "0" },',
    '                rhs: { expression }',
    '            })',
    '            break',
    '        case "true":',
    '            define({',
    '                lhs: { constant: "tt" },',
    '                rhs: { expression }',
    '            })',
    '            break',
    '        case "false":',
    '            define({',
    '                lhs: { constant: "ff" },',
    '                rhs: { expression }',
    '            })',
    '            break',
    '        case "var":',
    '            define({',
    '                lhs: { variable: expression },',
    '                rhs: { expression }',
    '            })',
    '            break',
    '        case "fn":',
    '        case "fun":',
    '            define({',
    '                lhs: { constant: expression.label },',
    '                rhs: { expression }',
    '            })',
    '            break',
    '        case "app": {',
    '            handle(expression.callable)',
    '            handle(expression.argument)',
    '            const addedFunctions = new Set<number>()',
    '            define({',
    '                lhs: {',
    '                    dynamic: ([callables]) => {',
    '                        for (const callable of callables) {',
    '                            if (typeof callable === "number" && !addedFunctions.has(callable)) {',
    '                                const func = label(callable)',
    '                                switch (func.type) {',
    '                                    case "fn":',
    '                                        break',
    '                                    case "fun":',
    '                                        define({',
    '                                            lhs: { constant: func.label },',
    '                                            rhs: { functionVariable: func }',
    '                                        })',
    '                                        break',
    '                                    default:',
    '                                        continue',
    '                                }',
    '                                define({',
    '                                    lhs: { expression: expression.argument },',
    '                                    rhs: { boundVariable: func }',
    '                                })',
    '                                define({',
    '                                    lhs: { expression: func.body },',
    '                                    rhs: { expression }',
    '                                })',
    '                                handle(func.body)',
    '                                addedFunctions.add(callable)',
    '                            }',
    '                        }',
    '                        return []',
    '                    },',
    '                    dependencies: [{ expression: expression.callable }]',
    '                },',
    '                rhs: { expression }',
    '            })',
    '            break',
    '        }',
    '        case "if": {',
    '            handle(expression.condition)',
    '            const addedConditions = new Set<boolean>()',
    '            define({',
    '                lhs: {',
    '                    dynamic: ([conditions]) => {',
    '                        if (conditions.has("tt") && !addedConditions.has(true)) {',
    '                            handle(expression.thenBody)',
    '                            define({',
    '                                lhs: { expression: expression.thenBody },',
    '                                rhs: { expression }',
    '                            })',
    '                            addedConditions.add(true)',
    '                        }',
    '                        if (conditions.has("ff") && !addedConditions.has(false)) {',
    '                            handle(expression.elseBody)',
    '                            define({',
    '                                lhs: { expression: expression.elseBody },',
    '                                rhs: { expression }',
    '                            })',
    '                            addedConditions.add(false)',
    '                        }',
    '                        return []',
    '                    },',
    '                    dependencies: [{ expression: expression.condition }]',
    '                },',
    '                rhs: { expression }',
    '            })',
    '            break',
    '        }',
    '        case "let":',
    '            handle(expression.value)',
    '            handle(expression.body)',
    '            define({',
    '                lhs: { expression: expression.value },',
    '                rhs: { boundVariable: expression }',
    '            })',
    '            define({',
    '                lhs: { expression: expression.body },',
    '                rhs: { expression }',
    '            })',
    '            break',
    '        case "+":',
    '            handleArithmetic(expression, (a, b) => a + b)',
    '            break',
    '        case "-":',
    '            handleArithmetic(expression, (a, b) => a - b)',
    '            break',
    '        case "*":',
    '            handleArithmetic(expression, (a, b) => a * b)',
    '            break',
    '        case "/":',
    '            handleArithmetic(expression, (a, b) => a / b)',
    '            break',
    '        case ">":',
    '            handleComparison(expression, (a, b) => a > b)',
    '            break',
    '        case "<":',
    '            handleComparison(expression, (a, b) => a < b)',
    '            break',
    '        case ">=":',
    '            handleComparison(expression, (a, b) => a >= b)',
    '            break',
    '        case "<=":',
    '            handleComparison(expression, (a, b) => a <= b)',
    '            break',
    '        case "==":',
    '            handleComparison(expression, (a, b) => a === b)',
    '            break',
    '        case "!=":',
    '            handleComparison(expression, (a, b) => a !== b)',
    '            break',
    '        case "&&":',
    '            handleBoolean(expression, (a, b) => a && b)',
    '            break',
    '        case "||":',
    '            handleBoolean(expression, (a, b) => a || b)',
    '            break',
    '    }',
    '}',
    'handle(expression)',
    ''
  ].join('\r\n')
}

export const defaultProgram = [
  '(',
  '  let f = (fn x => (x 1))',
  '  in (',
  '    let g = (fn y => (y + 2))',
  '    in (',
  '      let h = (fn z => (z + 3))',
  '      in (',
  '        (f g) + (f h)',
  '      )',
  '    )',
  '  )',
  ')',
  ''
].join('\r\n')

export const defaultRules = predefinedRules['Control Flow Analysis']
